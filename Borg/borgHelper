#!/usr/bin/env python3

import getopt,sys,os
import socket
import configparser
import subprocess,select


cfgfile="/root/.borghelperrc"

Version="0.5"
### TODO Rajouter un helpeur de prunage (en fonction du rc file), compactage
### TODO Mieux gerer les sorties d'erreure de borg (si pas tout les parametres
### TODO Mieux gerer les parametres "manquant" du borgrc (mountpoint)
### TODO Mieux aider la creation du borgrc
### TODO Mieux gerer le repertoire d'appel du programme (clause where) : elle n'est necessaire qu'au restore
# 0.5 Et la petite prune est la yeaaah
# 0.4 On rajoute le backup
# 0.3 Rajout d'un helper pour deleter une sauvegarde precise
# 0.2.1 Semblerait que le diff soit inverse
# 0.2 Maintenant on peiut faire un diff entre les 2 dernieres versions (en precisant rien)
# 0.1 Premiere version (officielle) qui reagit bien a toutes les commandes


def version():
    print(f"Version {Version}")
    sys.exit(0)

def usage(doc=None,debug=0):
    if doc is None:
        printer("   -H <Stats|Login|Mount|UMount|ListBkp|ListBkpFiles|Restore>")
        printer("       Permet d'avoir les documentations detaillés des differentes commandes")
        printer("   -c Stats [-n server-name/nickname]")
        printer("       Liste les backup references, et le fait qu'ils soient mount ou pas")
        printer("   -c Login [-s servername] [-n nickname] [-k keyfile.key] -p passphrase -r repo -m mountpoint")
        printer("       n se log sur le serveur, utilise que si le serveur n'est pas referencé")
        printer("   -c <Mount|UMount> [-n nickname/servername]")
        printer("       On monte et on demonte le FS (BIEN Penser a demonter !!!)")
        printer("   -c LstBkp [-n nickname/servername]")
        printer("       On liste les backup connus")
        printer("   -c LstBkpFls [-n nickname/servername] [-b backupid/last]")
        printer("       On liste les fichiers d'un backup precis")
        printer("   -c DiffBkp [-n nickname/servername] [-b backupid] [-w where]")
        printer("       Liste les mouvements des fichiers entre le backupid et le dernier backup")
        printer("   -c Restore [-n nickname/servername] [-b backupid/last] -f file2get -w where")
        printer("       On lance la restauration")
        printer("   -c DelBkp [-n nickname/servername] -b backupid")
        printer("       /!\ On delete un backup sur le repo /!\ DANGER")
        printer("   -c Bkp [-n nickname/servername]")
        printer("       On lance un backup")
        printer("   -c Prune [-n nickname/servername]")
        printer("      /!\ On delete les vieux backup sur le repo /!\ DANGER")
    elif doc == 'stats':
        printer("   -c Stats [-n server-name/nickname]")
        printer("       Affiche toutes les informations des serveurs connus")
        printer("           Sans parametre listera tout")
        printer("           Avec parametre donnera le detail d'un serveur")
    elif doc == 'login':
        printer("   -c Login [-s servername] [-n nickname] [-k keyfile.key] -p passphrase -r repo")
        printer("       Integre le serveur dans borgHelper")
        printer("           servername  : le nom du serveur, sert de filtre pour lister les backups, sinon srv local")
        printer("           nickname    : nom apparant du serveur, permet pour un  serveur d'avoir plusieur repo")
        printer("           keyfile     : le fichier de clefs")
        printer("           passpharse  : le mot de passe d'acces au repo")
        printer("           repo        : l'addresse du repo")
    elif doc == 'mount':
        printer("   -c Mount [-n nickname/servername]")
        printer("       Rend accessible les sauvegarde dans un repertoire visible via la commande Stat ou affiche en fin de mount")
        printer("       A utiliser rarement, car tant que le repo est monté, on ne peut plus backuper")
        printer("           si -n non precisé alores on travaille avec le serveur courant")
        printer("           nickname    : Le nom de l'enregistrement du serveur")
    elif doc == 'umount':
        printer("   -c UMount [-n nickname/servername]")
        printer("       Coupe cet acces")
        printer("           si -n non precisé alores on travaille avec le serveur courant")
        printer("           nickname    : Le nom de l'enregistrement du serveur")
    elif doc == 'lstbkp':
        printer("   -c ListBkp [-n nickname/servername]")
        printer("       Liste les backup (backupid) disponibles")
        printer("           si -n non precisé alores on travaille avec le serveur courant")
        printer("           nickname    : Le nom de l'enregistrement du serveur")
    elif doc == 'listbkpfls':
        printer("   -c LstBkpFls [-n nickname/servername] -b backupid")
        printer("       Liste les fichiers disponibles dans le backup backupid")
        printer("           si -n non precisé alores on travaille avec le serveur courant")
        printer("           nickname    : Le nom de l'enregistrement du serveur")
        printer("           backupid    : Le nom du backup interessant")
    elif doc == 'diffbkp':
        printer("   -c DiffBkp [-n nickname/servername] -b backupid [-w where]")
        printer("       Liste les mouvements des fichiers entre le backupid et le dernier backup")
        printer("           backupid    : Le nom du backup interessant (si pas precisé compare les 2 derniers)")
        printer("           where       : Repertoire de filtre")
    elif doc == 'restore':
        printer("   -c Restore [-n nickname/servername] -b backupid -f file2get -w where")
        printer("       Restaure l'arbo (ou fichier) file2berestored depuis le backup backupid dans l'emplacement where")
        printer("           si -n non precisé alores on travaille avec le serveur courant")
        printer("           nickname    : Le nom de l'enregistrement du serveur")
        printer("           backupid    : Le nom du backup interessant")
        printer("           file2get    : Le nom du fichier ou de l'arbo a recuperer")
        printer("           where       : Repertoire de restauration")
    else:
        printer(f"  Desole pas de documation pour la commande {doc}")

    sys.exit(1)

def printer(data,debug=0):
    print(data,file=sys.stderr)

def cfgread(nick,debug=0):
    #BORG_REPO #BORG_PASSPHRASE #BORG_RELOCATED_REPO_ACCESS_IS_OK
    #GLOB_ARCH #SER_NAME #NICK
    if os.path.exists(cfgfile) and os.path.isfile(cfgfile):
        config= configparser.ConfigParser()   
        config.optionxform=str
        config.read(cfgfile)
        if nick not in config.keys():
            return(None)
        else:
            #pretab={}
            #for i in config[nick].keys():
            #    printer(i)
            #    printer(config[nick][i])
            #    pretab[i]=config[nick][i]
            #printer("show must go on")
            #return(pretab)
            return(config[nick])
    else:
        return(None)

def cfgreaded(nick,debug=0):
    cfg=cfgread(nick,debug=debug)
    if cfg is None:
        printer("Ce serveur est inconnu")
        sys.exit(3)
    return(cfg)


def cfgwrite(nick,serna,passphrase,repo,mountpoint,debug=0):
    config= configparser.ConfigParser()
    config.optionxform=str
    config.read(cfgfile)

    config[nick]={}
    config[nick]['BORG_REPO']=repo
    config[nick]['BORG_PASSPHRASE']=passphrase
    config[nick]['SER_NAME']=serna
    config[nick]['GLOB_ARCH']=serna+'-root-*'
    if mountpoint is None:
        config[nick]['MOUNTPOINT']="/mnt/borg/"+nick
    else:
        config[nick]['MOUNTPOINT']=mountpoint

    with open(cfgfile, 'w') as fd:
        config.write(fd)
        fd.close()

def affconf(nick):
    cfg=cfgreaded(nick)
    print(nick+': ',end='')
    if mountedornot(cfg['MOUNTPOINT'],debug=debug):
        print('**Mounted**')
    else:
        print('Not Mounted')
    for i in cfg.keys():
        print(f"  {i}={cfg[i]}")
    
def cmd_stats(nick=None,debug=0):
    if os.path.exists(cfgfile) and os.path.isfile(cfgfile):
        config= configparser.ConfigParser()   
        config.optionxform=str
        config.read(cfgfile)
        if nick is None:
            for n in config.keys():
                if n in 'DEFAULT':
                    continue
                affconf(n)
        elif nick in config.keys():
            affconf(nick)
        else:
            print(f'{nick} pas trouvé dans {cfgfile}')
            sys.exit(1)
    else:
        printer(f'Fichier {cfgfile} absent')
        sys.exit(2)


def cmd_login(serna,nick,keyfile,passphrase,repo,mountpoint,debug=0):
    cfgwrite(nick,serna,passphrase,repo,mountpoint,debug=debug)
    cfg=cfgread(nick,debug=debug)
    if keyfile is not None:
        if os.path.exists(keyfile) and os.path.isfile(keyfile):
            boex(nick,['key','import',repo,keyfile],debug=debug)
        else:
            printer("Fichier "+keyfile+" absent, Mais attention, machine "+nick+" integre")
            sys.exit(2)

def mountedornot(mountpoint,debug=0):
    founded=False
    if debug:
        printer(f' On control {mountpoint}')
    with open('/proc/mounts') as fd:
        while (line := fd.readline()) and not founded:
            if mountpoint in line:
                founded=True
        fd.close()
    return(founded)

def cmd_mount(nick,debug=0):
    cfg=cfgreaded(nick)

    if os.path.exists(cfg['MOUNTPOINT']) and os.path.isdir(cfg['MOUNTPOINT']) and len(os.listdir(cfg['MOUNTPOINT'])) == 0:
        if(not mountedornot(cfg['MOUNTPOINT'],debug=debug)):
            boex(nick,['mount','--glob-archives',cfg['GLOB_ARCH'],cfg['BORG_REPO'],cfg['MOUNTPOINT']],debug=debug)
        else:
            printer('Deja monte')
            sys.exit(3)
    else:
        printer("Il faut que le repertoire "+cfg['MOUNTPOINT']+" existe et soit vide!")
        sys.exit(2)

def cmd_umount(nick,debug=0):
    cfg=cfgreaded(nick,debug=debug)
    if(mountedornot(cfg['MOUNTPOINT'],debug=debug)):
        boex(nick,['umount',cfg['MOUNTPOINT']],debug=debug)
    else:
        printer('Pas monte')
        sys.exit(3)

def cmd_lstbkp(nick,debug=0):
    cfg=cfgreaded(nick,debug=debug)
    boex(nick,['list','--glob-archives',cfg['GLOB_ARCH']],debug=debug)

def getlastbkp(nick,nbl=1,debug=0):
    cfg=cfgreaded(nick,debug=debug)
    lines=boex(nick,['list','--glob-archives',cfg['GLOB_ARCH']],ret=True,debug=debug)
    ret=[]
    for i in range(nbl*-1,0):
        ret.append(lines[i].split(' ')[0])
    return(ret)
    #return(lines[-1].split(' ')[0])

def cmd_lstfiles(nick,bid,debug=0):
    cfg=cfgreaded(nick,debug=debug)
    if bid is None:
        bid=getlastbkp(nick,debug=debug)[0]
    boex(nick,['list','--glob-archives',cfg['GLOB_ARCH'],'::'+bid],debug=debug)

def cmd_diffbkp(nick,bid,where,debug=0):
    cfg=cfgreaded(nick,debug=debug)
    twodiff=getlastbkp(nick,2,debug=debug)
    if bid is None:
        bid=twodiff[1]
    ladiff=twodiff[0]
    if ladiff==bid:
        printer("Desole, ce sont les memes backups")
        sys.exit(1)

    arg=['diff',f"{cfg['BORG_REPO']}::{ladiff}", bid]
    if where is not None:
        arg.append(where)

    boex(nick,arg,debug=debug)

def cmd_resto(nick,bid,ftor,where,debug=0):
    cfg=cfgreaded(nick,debug=debug)
    if bid is None:
        bid=getlastbkp(nick,debug=debug)[0]
    boex(nick,['extract','--exclude','*/log/*','::'+bid,ftor],rep=where,debug=debug)

def cmd_delbkp(nick,bid,debug=0):
    cfg=cfgreaded(nick,debug=debug)
    boex(nick,['delete','::'+bid],debug=debug)
    boex(nick,['compact','--cleanup-commits'],debug=debug)


def cmd_prune(nick,debug=0):
    cfg=cfgreaded(nick,debug=debug)
    cmd=['prune']
    for i in list(cfg.keys()):
        if 'KEEP_DAILY' == i:
            cmd.append('--keep-daily')
            cmd.append(cfg[i])
        elif 'KEEP_WEEKLY' == i:
            cmd.append('--keep-weekly')
            cmd.append(cfg[i])
        elif 'KEEP_MONTHLY' == i:
            cmd.append('--keep-monthly')
            cmd.append(cfg[i])
        elif 'KEEP_YEARLY' == i:
            cmd.append('--keep-yearly')
            cmd.append(cfg[i])
        elif 'KEEP_HOURLY' == i:
            cmd.append('--keep-hourly')
            cmd.append(cfg[i])

    if len(cmd) >1:
        # BORG_PASSPHRASE=$pass borg prune --keep-daily 31 --save-space --info --list --stats --glob-archives="$arcg-*" $repo
        cmd.extend(f'--save-space --info --list --stats --glob-archives={cfg["GLOB_ARCH"]}'.split(' '))
        boex(nick,cmd,debug=debug)
        boex(nick,['compact','--cleanup-commits'],debug=debug)
    else:
        usage('prune')

    

def cmd_bkp(nick,debug=0):
    cfg=cfgreaded(nick,debug=debug)

###    SetEnv BORG_PASSPHRASE=XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX BORG_REPO=repo01:/mnt/borg03/sxb-03
### Ce qui change par rapport a un vrai boex
###    Variable env BORG_REPO reecrite
###    Precedence du ssh
###
###    cmda=f"ssh -Ao StrictHostKeyChecking=no -o LogLevel=ERROR -o UserKnownHostsFile=/dev/null {host} 'borg create --log-json --json --debug -v --stats "
###    cmdb="::{fqdn}-root-{now} / --exclude /media --exclude /dev --exclude /proc --exclude /sys --exclude /var/run --exclude /run --exclude /lost+found --exclude /mnt --exclude /var/lib/lxcfs --exclude /tmp --exclude /var/lib/docker --exclude-if-present .nobackup  --exclude-caches --exclude-nodump --keep-exclude-tags'"

### Ce qu'il faut faire
###     1. Stocker les ordres d'exclusion du backup (le reste sera pour le moment hardcodé)
###     2. Preceder la commande du backup ssh proprement (avec enregistrement de la clef)
###     3. Traiter les codes retours
    preBorg=['ssh','-o','SendEnv BORG_*']
    if 'SSH_REMFO' in cfg.keys():
        preBorg.append('-R')
        preBorg.append(cfg['SSH_REMFO'])
    preBorg.extend(f'-A -o VisualHostKey=no -o StrictHostKeyChecking=accept-new {cfg["SER_NAME"]}'.split(' '))

    create=['create']
    create.extend(('--log-json --json --debug -v --stats ::{fqdn}-root-{now} /').split(' '))
    if 'EXCLUDE' not in list(cfg.keys()):
        printer(list(cfg.keys()))
        printer("Il est necessaire que EXLUDE soit configures dans ~/.borghelperrc")
        printer('  EXCLUDE = --exclude /media --exclude /dev --exclude /proc --exclude /sys --exclude /var/run --exclude /run --exclude /lost+found --exclude /mnt --exclude /var/lib/lxcfs --exclude /tmp --exclude /var/lib/docker --exclude-if-present .nobackup  --exclude-caches --exclude-nodump --keep-exclude-tags')
        exit(1)
    create.extend(cfg['EXCLUDE'].split(' '))

    if 'SSH_REPO' in cfg.keys():
        forceEnv={}
        forceEnv['BORG_REPO']=cfg['SSH_REPO']
    else:
        forceEnv=None

    boex(nick,create,preBorg=preBorg,forceEnv=forceEnv,debug=debug)
    
def boex(nick,arg,rep='/tmp',ret=False,debug=0,preBorg=None,forceEnv=None):
    cfg=cfgreaded(nick,debug=debug)
    varcur=os.environ.copy()
    varfut={}
    for k in list(cfg.keys()):
        if k in ['BORG_REPO','BORG_PASSPHRASE','BORG_REMOTE_PATH','BORG_RSH','BORG_SHOW_SYSINFO','BORG_RELOCATED_REPO_ACCESS_IS_OK']:
            varfut[k]=cfg[k]

    if forceEnv is not None:
        for k in list(forceEnv.keys()):
            varfut[k]=forceEnv[k]

    if debug != 0:
        printer(varfut)

    if preBorg is not None:
        commande=preBorg
        commande.append('borg')
    else:
        commande=['borg']
    commande.extend(arg)
    varfut['PATH']=varcur['PATH']
    if debug:
        for k in varfut:
            printer(f' {k}={varfut[k]}')
        printer(f"+{rep}")
        printer(commande)
        printer(f"{' '.join(commande)}")
        printer(f"+{rep} >{' '.join(commande)}")
        if arg[1] in "extract":
            sys.exit(4)
    ps=subprocess.Popen(commande,encoding ='utf-8',
                         env=varfut,cwd=rep,bufsize=8192,
                         stdin=subprocess.PIPE,
                         stdout=subprocess.PIPE,
                         stderr=subprocess.PIPE)
    inf, errs = ps.communicate()
    if ret:
        return(''.join(inf).splitlines())
    else:
        for line in inf:
            print(line,end='')
        if len(errs):
            print(f'\n===================({ps.returncode})=======================================\n')
            for line in errs:
                print(line,end="")
    
        if ps.returncode != 0:
            sys.exit(ps.returncode)


######### Analyse Arguments

try:
    opts, args = getopt.getopt(sys.argv[1:],"c:hH:s:n:k:p:r:m:b:f:w:dv", ["help"])
except getopt.GetoptError as err:
    print(err)  # will print something like "option -a not recognized"
    usage()
    sys.exit(2)

debug=0
cmd=None

optab={ 'stats'     :'cdn',      'login'     :'cdsnkprm',
        'mount'     :'cdn',      'umount'    :'cdn',
        'lstbkp'    :'cdn',      'lstbkpfls' :'cdnb',
        'restore'   :'cdnbfw',   'diffbkp'   :'cdnbw',
        'delbkp'    :'cdnb',     'bkp'       :'cdn',
        'prune'     :'cdn' }

for opt,arg in opts:
    if   opt in '-h':
        usage()
    elif opt in '-H':
        usage(arg.lower())
    elif opt in '-c':
        cmd=arg.lower()
    elif opt in '-d':
        debug+=1
    elif opt in '-v':
        version()
        

if cmd is None or cmd not in optab.keys():
    usage()
# On part du principe que usage(xxx) quitte avec un exitcode

options={}
nick=socket.gethostname()

for opt,arg in opts:
    if opt[1] not in optab[cmd]:
        printer("step2"+opt[1])
        usage(cmd)
    else:
        options[opt]=arg
    if opt in '-n':
        nick=arg

if debug != 0:
    printer(f'La commande fume {cmd}')

if   cmd == 'stats':
    if '-n' in options.keys():
        cmd_stats(nick)
    else:
        cmd_stats()
elif cmd == 'login':
    # TODO blocquer si mounted
    # printer("-c Login [-s servername] [-n nickname] [-k keyfile.key] -p passphrase -r repo")
    if '-s' not in options.keys():
        serna=socket.gethostname()
    else:
        serna=options['-s']
    if '-n' not in options.keys():
        nick=serna
    if '-k' not in options.keys():
        options['-k']=None
    if '-p' not in options.keys():
        printer('p')
        usage(cmd)
    if '-r' not in options.keys():
        printer('r')
        usage(cmd)
    if '-m' not in options.keys():
        options['-m']=None
    cmd_login(serna,nick,options['-k'],options['-p'],options['-r'],options['-m'],debug=debug)
elif cmd == 'mount':
    # printer("-c Mount [-n nickname/servername]")
    cmd_mount(nick,debug=debug)
elif cmd == 'umount':
    # printer("-c UMount [-n nickname/servername]")
    cmd_umount(nick,debug=debug)
elif cmd == 'lstbkp':
    # printer("-c LstBkp [-n nickname/servername]")
    cmd_lstbkp(nick,debug=debug)
elif cmd == 'lstbkpfls':
    # printer("-c LstBkpFls [-n nickname/servername] [-b backupid/last]")
    if '-b' not in options.keys() or 'last' in options['-b']:
        options['-b']=None
    cmd_lstfiles(nick,options['-b'],debug=debug)
elif cmd == 'diffbkp':
    # printer("-c DiffBkp [-n nickname/servername] [-b backupid] -w where")
    if '-b' not in options.keys():
        options['-b']=None
    if '-w' not in options.keys():
        options['-w']=None
    cmd_diffbkp(nick,options['-b'],options['-w'],debug=debug)
elif cmd == 'restore':
    # printer("-c Restore [-n nickname/servername] [-b backupid/last] -f file2get -w where")
    if '-b' not in options.keys() or 'last' in options['-b']:
        options['-b']=None
    if '-f' not in options.keys():
        usage(cmd)
    if '-w' not in options.keys():
        usage(cmd)
    cmd_resto(nick,options['-b'],options['-f'],options['-w'],debug=debug)
elif cmd == 'delbkp':
    # printer("   -c DelBkp [-n nickname/servername] -b backupid")
    if '-b' not in options.keys() or 'last' in options['-b']:
        usage(cmd)
    cmd_delbkp(nick,options['-b'],debug=debug)
elif cmd == 'bkp':
    # printer("   -c Bkp [-n nickname/servername]")
    cmd_bkp(nick,debug=debug)
elif cmd == 'prune':
    # printer("   -c Prune [-n nickname/servername]")
    cmd_prune(nick,debug=debug)
else:
    printer("Mais comment on peut en arriver la ?")
    usage()