#!/usr/bin/env python3

import getopt,sys,os
import socket
import configparser
import subprocess,select
import json


cfgfile="/root/.borghelperrc"

Version="0.8"
### TODO Rajouter un helpeur de prunage (en fonction du rc file), compactage
### TODO Mieux gerer les sorties d'erreure de borg (si pas tout les parametres
### TODO Mieux gerer les parametres "manquant" du borgrc (mountpoint)
### TODO Mieux aider la creation du borgrc
### TODO Mieux gerer le repertoire d'appel du programme (clause where) : elle n'est necessaire qu'au restore
# 0.8 1er rapport
# 0.7.1 flushing 4 print 2 screen
# 0.6 prise en compte des backup locaux
# 0.5 Correction : on ne force plus le chemin d'execution tout le temps a /tmp
# 0.5 Et la petite prune est la yeaaah
# 0.4 On rajoute le backup
# 0.3 Rajout d'un helper pour deleter une sauvegarde precise
# 0.2.1 Semblerait que le diff soit inverse
# 0.2 Maintenant on peiut faire un diff entre les 2 dernieres versions (en precisant rien)
# 0.1 Premiere version (officielle) qui reagit bien a toutes les commandes

def version():
    print(f"Version {Version}")
    sys.exit(0)

def usage(doc=None,debug=0):
    if doc is None:
        printer("   -H <Stats|Login|Mount|UMount|ListBkp|ListBkpFiles|Restore>")
        printer("       Permet d'avoir les documentations detaillés des differentes commandes")
        printer("   -c Stats [-n server-name/nickname]")
        printer("       Liste les backup references, et le fait qu'ils soient mount ou pas")
        printer("   -c Login [-s servername] [-n nickname] [-k keyfile.key] -p passphrase -r repo -m mountpoint")
        printer("       n se log sur le serveur, utilise que si le serveur n'est pas referencé")
        printer("   -c <Mount|UMount> [-n nickname/servername]")
        printer("       On monte et on demonte le FS (BIEN Penser a demonter !!!)")
        printer("   -c LstBkp [-n nickname/servername]")
        printer("       On liste les backup connus")
        printer("   -c LstBkpFls [-n nickname/servername] [-b backupid/last]")
        printer("       On liste les fichiers d'un backup precis")
        printer("   -c Report [-n nickname/servername] [-b backupid/last]")
        printer("       Rapport sur le dernier (ou pas) backup")
        printer("   -c DiffBkp [-n nickname/servername] [-b backupid] [-w where]")
        printer("       Liste les mouvements des fichiers entre le backupid et le dernier backup")
        printer("   -c Restore [-n nickname/servername] [-b backupid/last] -f file2get -w where")
        printer("       On lance la restauration")
        printer("   -c DelBkp [-n nickname/servername] -b backupid")
        printer("       /!\ On delete un backup sur le repo /!\ DANGER")
        printer("   -c Bkp [-n nickname/servername]")
        printer("       On lance un backup")
        printer("   -c Prune [-n nickname/servername]")
        printer("      /!\ On delete les vieux backup sur le repo /!\ DANGER")
    elif doc == 'stats':
        printer("   -c Stats [-n server-name/nickname]")
        printer("       Affiche toutes les informations des serveurs connus")
        printer("           Sans parametre listera tout")
        printer("           Avec parametre donnera le detail d'un serveur")
    elif doc == 'login':
        printer("   -c Login [-s servername] [-n nickname] [-k keyfile.key] -p passphrase -r repo")
        printer("       Integre le serveur dans borgHelper")
        printer("           servername  : le nom du serveur, sert de filtre pour lister les backups, sinon srv local")
        printer("           nickname    : nom apparant du serveur, permet pour un  serveur d'avoir plusieur repo")
        printer("           keyfile     : le fichier de clefs")
        printer("           passpharse  : le mot de passe d'acces au repo")
        printer("           repo        : l'addresse du repo")
    elif doc == 'mount':
        printer("   -c Mount [-n nickname/servername]")
        printer("       Rend accessible les sauvegarde dans un repertoire visible via la commande Stat ou affiche en fin de mount")
        printer("       A utiliser rarement, car tant que le repo est monté, on ne peut plus backuper")
        printer("           si -n non precisé alores on travaille avec le serveur courant")
        printer("           nickname    : Le nom de l'enregistrement du serveur")
    elif doc == 'umount':
        printer("   -c UMount [-n nickname/servername]")
        printer("       Coupe cet acces")
        printer("           si -n non precisé alores on travaille avec le serveur courant")
        printer("           nickname    : Le nom de l'enregistrement du serveur")
    elif doc == 'lstbkp':
        printer("   -c ListBkp [-n nickname/servername]")
        printer("       Liste les backup (backupid) disponibles")
        printer("           si -n non precisé alores on travaille avec le serveur courant")
        printer("           nickname    : Le nom de l'enregistrement du serveur")
    elif doc == 'listbkpfls':
        printer("   -c LstBkpFls [-n nickname/servername] -b backupid")
        printer("       Liste les fichiers disponibles dans le backup backupid")
        printer("           si -n non precisé alores on travaille avec le serveur courant")
        printer("           nickname    : Le nom de l'enregistrement du serveur")
        printer("           backupid    : Le nom du backup interessant")
    elif doc == 'diffbkp':
        printer("   -c DiffBkp [-n nickname/servername] -b backupid [-w where]")
        printer("       Liste les mouvements des fichiers entre le backupid et le dernier backup")
        printer("           backupid    : Le nom du backup interessant (si pas precisé compare les 2 derniers)")
        printer("           where       : Repertoire de filtre")
    elif doc == 'restore':
        printer("   -c Restore [-n nickname/servername] -b backupid -f file2get -w where")
        printer("       Restaure l'arbo (ou fichier) file2berestored depuis le backup backupid dans l'emplacement where")
        printer("           si -n non precisé alores on travaille avec le serveur courant")
        printer("           nickname    : Le nom de l'enregistrement du serveur")
        printer("           backupid    : Le nom du backup interessant")
        printer("           file2get    : Le nom du fichier ou de l'arbo a recuperer")
        printer("           where       : Repertoire de restauration")
    else:
        printer(f"  Desole pas de documation pour la commande {doc}")

    sys.exit(1)

def printer(data,debug=0):
    print(data,file=sys.stderr)

def cfgread(nick,debug=0):
    #BORG_REPO #BORG_PASSPHRASE #BORG_RELOCATED_REPO_ACCESS_IS_OK
    #GLOB_ARCH #SER_NAME #NICK
    if os.path.exists(cfgfile) and os.path.isfile(cfgfile):
        config= configparser.ConfigParser()   
        config.optionxform=str
        config.read(cfgfile)
        if nick not in config.keys():
            return(None)
        else:
            #pretab={}
            #for i in config[nick].keys():
            #    printer(i)
            #    printer(config[nick][i])
            #    pretab[i]=config[nick][i]
            #printer("show must go on")
            #return(pretab)
            return(config[nick])
    else:
        return(None)

def cfgreaded(nick,debug=0):
    cfg=cfgread(nick,debug=debug)
    if cfg is None:
        printer("Ce serveur est inconnu")
        sys.exit(3)
    return(cfg)

def cfgwrite(nick,serna,passphrase,repo,mountpoint,debug=0):
    config= configparser.ConfigParser()
    config.optionxform=str
    config.read(cfgfile)

    config[nick]={}
    config[nick]['BORG_REPO']=repo
    config[nick]['BORG_PASSPHRASE']=passphrase
    config[nick]['SER_NAME']=serna
    config[nick]['GLOB_ARCH']=serna+'-root-*'
    if mountpoint is None:
        config[nick]['MOUNTPOINT']="/mnt/borg/"+nick
    else:
        config[nick]['MOUNTPOINT']=mountpoint

    with open(cfgfile, 'w') as fd:
        config.write(fd)
        fd.close()

def convert_octets_readable(size_in_bytes,sib=1000):
    suffixes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']
    index = 0

    while size_in_bytes >= sib and index < len(suffixes) - 1:
        size_in_bytes /= sib
        index += 1

    # Formatage avec deux chiffres après la virgule
    return f"{size_in_bytes:.2f} {suffixes[index]}"

def affconf(nick):
    cfg=cfgreaded(nick)
    print(nick+': ',end='')
    if mountedornot(cfg['MOUNTPOINT'],debug=debug):
        print('**Mounted**')
    else:
        print('Not Mounted')
    for i in cfg.keys():
        print(f"  {i}={cfg[i]}")
    
def cmd_stats(nick=None,debug=0):
    if os.path.exists(cfgfile) and os.path.isfile(cfgfile):
        config= configparser.ConfigParser()   
        config.optionxform=str
        config.read(cfgfile)
        if nick is None:
            for n in config.keys():
                if n in 'DEFAULT':
                    continue
                affconf(n)
        elif nick in config.keys():
            affconf(nick)
        else:
            print(f'{nick} pas trouvé dans {cfgfile}')
            sys.exit(1)
    else:
        printer(f'Fichier {cfgfile} absent')
        sys.exit(2)


def cmd_login(serna,nick,keyfile,passphrase,repo,mountpoint,debug=0):
    cfgwrite(nick,serna,passphrase,repo,mountpoint,debug=debug)
    cfg=cfgread(nick,debug=debug)
    if keyfile is not None:
        if os.path.exists(keyfile) and os.path.isfile(keyfile):
            boex(nick,['key','import',repo,keyfile],debug=debug)
        else:
            printer("Fichier "+keyfile+" absent, Mais attention, machine "+nick+" integre")
            sys.exit(2)

def mountedornot(mountpoint,debug=0):
    founded=False
    if debug:
        printer(f' On control {mountpoint}')
    with open('/proc/mounts') as fd:
        while (line := fd.readline()) and not founded:
            if mountpoint in line:
                founded=True
        fd.close()
    return(founded)

def cmd_mount(nick,debug=0):
    cfg=cfgreaded(nick)

    if os.path.exists(cfg['MOUNTPOINT']) and os.path.isdir(cfg['MOUNTPOINT']) and len(os.listdir(cfg['MOUNTPOINT'])) == 0:
        if(not mountedornot(cfg['MOUNTPOINT'],debug=debug)):
            boex(nick,['mount','--glob-archives',cfg['GLOB_ARCH'],cfg['BORG_REPO'],cfg['MOUNTPOINT']],debug=debug)
        else:
            printer('Deja monte')
            sys.exit(3)
    else:
        printer("Il faut que le repertoire "+cfg['MOUNTPOINT']+" existe et soit vide!")
        sys.exit(2)

def cmd_umount(nick,debug=0):
    cfg=cfgreaded(nick,debug=debug)
    if(mountedornot(cfg['MOUNTPOINT'],debug=debug)):
        boex(nick,['umount',cfg['MOUNTPOINT']],debug=debug)
    else:
        printer('Pas monte')
        sys.exit(3)

def cmd_lstbkp(nick,debug=0):
    cfg=cfgreaded(nick,debug=debug)
    boex(nick,['list','--glob-archives',cfg['GLOB_ARCH']],debug=debug)

def getlastbkp(nick,nbl=1,debug=0):
    cfg=cfgreaded(nick,debug=debug)
    lines=boex(nick,['list','--glob-archives',cfg['GLOB_ARCH']],ret=True,debug=debug)
    ret=[]
    for i in range(nbl*-1,0):
        ret.append(lines[i].split(' ')[0])
    return(ret)
    #return(lines[-1].split(' ')[0])

def cmd_lstfiles(nick,bid,debug=0):
    cfg=cfgreaded(nick,debug=debug)
    if bid is None:
        bid=getlastbkp(nick,debug=debug)[0]
    boex(nick,['list','--glob-archives',cfg['GLOB_ARCH'],'::'+bid],debug=debug)

def cmd_report(nick,bid,debug=0):
    import re
    cfg=cfgreaded(nick,debug=debug)
    pruneme=[]
    for i in cmd_prune(nick,dryrun=True,debug=debug):
        if 'Would prune:' in i:
            pruneme.append(((re.sub(r'( )*',r'\1',i)).split(' '))[2])
    if bid is None:
        bid=getlastbkp(nick,debug=debug)[0]
    r=json.loads('\n'.join(boex(nick,['info','--json','--glob-archives',cfg['GLOB_ARCH']],ret=True,debug=debug)))
    #print(r)

    resume={}
    resume['duration']=0
    for i in ['duration','compressed_size','deduplicated_size','nfiles','original_size','prunable']:
        resume[i]=0

    c=0
    kept={}
    for i in r['archives']:
        resume['duration']+=i['duration']
        resume['compressed_size']+=i['stats']['compressed_size']
        resume['deduplicated_size']+=i['stats']['deduplicated_size']
        resume['original_size']+=i['stats']['original_size']
        resume['nfiles']+=i['stats']['nfiles']

        i['command_line']=[]
        i['chunker_params']=[]
        kept[i['name']]={}
        kept[i['name']]['name']             =i['name']
        #kept[i['name']]['start']            =i['start']
        kept[i['name']]['durationM']        =i['duration']/60
        kept[i['name']]['original_size']    =convert_octets_readable(i['stats']['original_size'])
        kept[i['name']]['compressed_size']  =convert_octets_readable(i['stats']['compressed_size'])
        kept[i['name']]['deduplicated_size']=convert_octets_readable(i['stats']['deduplicated_size'])
        kept[i['name']]['nfiles']           =i['stats']['nfiles']
        
        if i['name'] in pruneme:
            i['pruneme']='Yes'
            if i['stats']['original_size'] > 0:
                kept[i['name']]['original_size']    ="-"+kept[i['name']]['original_size']
                kept[i['name']]['compressed_size']  ="-"+kept[i['name']]['compressed_size']
                kept[i['name']]['deduplicated_size']="-"+kept[i['name']]['deduplicated_size']
            kept[i['name']]['prunMe']='Yes'
            #resume['prunable']+=i['stats']['compressed_size']
            resume['prunable']+=i['stats']['deduplicated_size']
        else:
            i['pruneme']='No'
            kept[i['name']]['prunMe']='No'
        c+=1

    resume['moy_duration']=resume['duration']/c
    resume['unique_csize']=r['cache']['stats']['unique_csize']
    for i in ['duration','compressed_size','deduplicated_size','nfiles','original_size','unique_csize']:
    #for i in ['duration','compressed_size','deduplicated_size','nfiles','original_size']:
        resume['moy_'+i]=convert_octets_readable(resume[i]/c)
        resume[i]=convert_octets_readable(resume[i])
    resume['prunable']=convert_octets_readable(resume['prunable'])
    resume['last']=r['archives'][c-1]['start']

    if debug > 0:
        print(json.dumps(r,indent=4))

    print(json.dumps(resume,indent=4))
    print(json.dumps(kept,indent=4))
    if ':' not in r['repository']['location']:
        print("Il faudrait calculer ce qu'il reste sur ce sto, et mettre une condistionnelle sur les 'var d'env'")



def cmd_diffbkp(nick,bid,where,debug=0):
    cfg=cfgreaded(nick,debug=debug)
    twodiff=getlastbkp(nick,2,debug=debug)
    if bid is None:
        bid=twodiff[1]
    ladiff=twodiff[0]
    if ladiff==bid:
        printer("Desole, ce sont les memes backups")
        sys.exit(1)

    arg=['diff',f"{cfg['BORG_REPO']}::{ladiff}", bid]
    if where is not None:
        arg.append(where)

    boex(nick,arg,debug=debug)

def cmd_resto(nick,bid,ftor,where,debug=0):
    cfg=cfgreaded(nick,debug=debug)
    if bid is None:
        bid=getlastbkp(nick,debug=debug)[0]
    boex(nick,['extract','--exclude','*/log/*','::'+bid,ftor],rep=where,debug=debug)

def cmd_delbkp(nick,bid,debug=0):
    cfg=cfgreaded(nick,debug=debug)
    boex(nick,['delete','::'+bid],debug=debug)
    boex(nick,['compact','--cleanup-commits'],debug=debug)


def cmd_prune(nick,dryrun=False,debug=0):
    cfg=cfgreaded(nick,debug=debug)
    cmd=['prune']
    for i in list(cfg.keys()):
        if 'KEEP_DAILY' == i:
            cmd.append('--keep-daily')
            cmd.append(cfg[i])
        elif 'KEEP_WEEKLY' == i:
            cmd.append('--keep-weekly')
            cmd.append(cfg[i])
        elif 'KEEP_MONTHLY' == i:
            cmd.append('--keep-monthly')
            cmd.append(cfg[i])
        elif 'KEEP_YEARLY' == i:
            cmd.append('--keep-yearly')
            cmd.append(cfg[i])
        elif 'KEEP_HOURLY' == i:
            cmd.append('--keep-hourly')
            cmd.append(cfg[i])

    if len(cmd) >1:
        # BORG_PASSPHRASE=$pass borg prune --keep-daily 31 --save-space --info --list --stats --glob-archives="$arcg-*" $repo
        if dryrun:
            cmd.append('--dry-run')
        else:
            cmd.append('--stats')
        cmd.extend(f'--save-space --info --list --glob-archives={cfg["GLOB_ARCH"]}'.split(' '))
        ret=boex(nick,cmd,ret=dryrun,debug=debug,getStdErr=True)
        if not dryrun:
            boex(nick,['compact','--cleanup-commits'],debug=debug)
        else:
            return(ret)
    else:
        usage('prune')

    

def cmd_bkp(nick,debug=0):
    cfg=cfgreaded(nick,debug=debug)

###    SetEnv BORG_PASSPHRASE=XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX BORG_REPO=repo01:/mnt/borg03/sxb-03
### Ce qui change par rapport a un vrai boex
###    Variable env BORG_REPO reecrite
###    Precedence du ssh
###
###    cmda=f"ssh -Ao StrictHostKeyChecking=no -o LogLevel=ERROR -o UserKnownHostsFile=/dev/null {host} 'borg create --log-json --json --debug -v --stats "
###    cmdb="::{fqdn}-root-{now} / --exclude /media --exclude /dev --exclude /proc --exclude /sys --exclude /var/run --exclude /run --exclude /lost+found --exclude /mnt --exclude /var/lib/lxcfs --exclude /tmp --exclude /var/lib/docker --exclude-if-present .nobackup  --exclude-caches --exclude-nodump --keep-exclude-tags'"

### Ce qu'il faut faire
###     1. Stocker les ordres d'exclusion du backup (le reste sera pour le moment hardcodé)
###     2. Preceder la commande du backup ssh proprement (avec enregistrement de la clef)
###     3. Traiter les codes retours
    if 'SSH_REPO' in cfg.keys():
        forceEnv={}
        forceEnv['BORG_REPO']=cfg['SSH_REPO']
    else:
        forceEnv=None

    preBorg=['ssh','-o','SendEnv BORG_*']
    if 'SSH_REMFO' in cfg.keys():
        preBorg.append('-R')
        preBorg.append(cfg['SSH_REMFO'])
    preBorg.extend(f'-A -o VisualHostKey=no -o StrictHostKeyChecking=accept-new {cfg["SER_NAME"]}'.split(' '))
    if len(cfg['SSH_REMFO']) == 0:
        preBorg=None

    create=['create']
    #create.extend(('--log-json --json --debug -v --stats '+cfg['BORG_REPO']+'::{fqdn}-root-{now} /').split(' '))
    create.extend(('--log-json --json --debug -v --stats ::{fqdn}-root-{now} /').split(' '))
    if 'EXCLUDE' not in list(cfg.keys()):
        printer(list(cfg.keys()))
        printer("Il est necessaire que EXLUDE soit configures dans ~/.borghelperrc")
        printer('  EXCLUDE = --exclude /media --exclude /dev --exclude /proc --exclude /sys --exclude /var/run --exclude /run --exclude /lost+found --exclude /mnt --exclude /var/lib/lxcfs --exclude /tmp --exclude /var/lib/docker --exclude-if-present .nobackup  --exclude-caches --exclude-nodump --keep-exclude-tags')
        exit(1)
    create.extend(cfg['EXCLUDE'].split(' '))


    boex(nick,create,preBorg=preBorg,forceEnv=forceEnv,debug=debug)
    
def boex(nick,arg,rep=None,ret=False,debug=0,preBorg=None,forceEnv=None,getStdErr=False):
    cfg=cfgreaded(nick,debug=debug)
    varcur=os.environ.copy()
    varfut={}
    if debug != 0:
        printer('Boex the first')
    for k in list(cfg.keys()):
        if k in ['BORG_REPO','BORG_PASSPHRASE','BORG_REMOTE_PATH','BORG_RSH','BORG_SHOW_SYSINFO','BORG_RELOCATED_REPO_ACCESS_IS_OK']:
            varfut[k]=cfg[k]

    if forceEnv is not None:
        for k in list(forceEnv.keys()):
            varfut[k]=forceEnv[k]

    if debug != 0:
        printer(varfut)

    if preBorg is not None:
        commande=preBorg
        commande.append('borg')
    else:
        commande=['borg']

    if rep is None:
        rep=os.getcwd()
    commande.extend(arg)
    varfut['PATH']=varcur['PATH']
    if debug:
        for k in varfut:
            printer(f' {k}={varfut[k]}')
        printer(f"+{rep}")
        printer(commande)
        printer(f"{' '.join(commande)}")
        printer(f"+{rep} >{' '.join(commande)}")
        if arg[1] in "extract":
            sys.exit(4)
    ps=subprocess.Popen(commande,encoding ='utf-8',
                         env=varfut,cwd=rep,bufsize=8192,
                         stdin=subprocess.PIPE,
                         stdout=subprocess.PIPE,
                         stderr=subprocess.PIPE)
    inf, errs = ps.communicate()
    if ret:
        if getStdErr:
            return(''.join(errs).splitlines())
        else:
            return(''.join(inf).splitlines())
    else:
        for line in inf:
            print(line,end='',flush=True)
        if len(errs):
            print(f'\n===================({ps.returncode})=======================================\n',flush=True)
            for line in errs:
                print(line,end="",flush=True)
    
        if ps.returncode != 0:
            sys.exit(ps.returncode)


######### Analyse Arguments

try:
    opts, args = getopt.getopt(sys.argv[1:],"c:hH:s:n:k:p:r:m:b:f:w:dv", ["help"])
except getopt.GetoptError as err:
    print(err)  # will print something like "option -a not recognized"
    usage()
    sys.exit(2)

debug=0
cmd=None

optab={ 'stats'     :'cdn',      'login'     :'cdsnkprm',
        'mount'     :'cdn',      'umount'    :'cdn',
        'lstbkp'    :'cdn',      'lstbkpfls' :'cdnb',
        'restore'   :'cdnbfw',   'diffbkp'   :'cdnbw',
        'delbkp'    :'cdnb',     'bkp'       :'cdn',
        'prune'     :'cdn',      'report'    :'cdnb' }

for opt,arg in opts:
    if   opt in '-h':
        usage()
    elif opt in '-H':
        usage(arg.lower())
    elif opt in '-c':
        cmd=arg.lower()
    elif opt in '-d':
        debug+=1
    elif opt in '-v':
        version()
        

if cmd is None or cmd not in optab.keys():
    usage()
# On part du principe que usage(xxx) quitte avec un exitcode

options={}
nick=socket.gethostname()

for opt,arg in opts:
    if opt[1] not in optab[cmd]:
        printer("step2"+opt[1])
        usage(cmd)
    else:
        options[opt]=arg
    if opt in '-n':
        nick=arg

if debug != 0:
    printer(f'La commande fume {cmd}')

if   cmd == 'stats':
    if '-n' in options.keys():
        cmd_stats(nick)
    else:
        cmd_stats()
elif cmd == 'login':
    # TODO blocquer si mounted
    # printer("-c Login [-s servername] [-n nickname] [-k keyfile.key] -p passphrase -r repo")
    if '-s' not in options.keys():
        serna=socket.gethostname()
    else:
        serna=options['-s']
    if '-n' not in options.keys():
        nick=serna
    if '-k' not in options.keys():
        options['-k']=None
    if '-p' not in options.keys():
        printer('p')
        usage(cmd)
    if '-r' not in options.keys():
        printer('r')
        usage(cmd)
    if '-m' not in options.keys():
        options['-m']=None
    cmd_login(serna,nick,options['-k'],options['-p'],options['-r'],options['-m'],debug=debug)
elif cmd == 'mount':
    # printer("-c Mount [-n nickname/servername]")
    cmd_mount(nick,debug=debug)
elif cmd == 'umount':
    # printer("-c UMount [-n nickname/servername]")
    cmd_umount(nick,debug=debug)
elif cmd == 'lstbkp':
    # printer("-c LstBkp [-n nickname/servername]")
    cmd_lstbkp(nick,debug=debug)
elif cmd == 'lstbkpfls':
    # printer("-c LstBkpFls [-n nickname/servername] [-b backupid/last]")
    if '-b' not in options.keys() or 'last' in options['-b']:
        options['-b']=None
    cmd_lstfiles(nick,options['-b'],debug=debug)
elif cmd == 'report':
    # printer("   -c Report [-n nickname/servername] [-b backupid/last]")
    if '-b' not in options.keys() or 'last' in options['-b']:
        options['-b']=None
    cmd_report(nick,options['-b'],debug=debug)
elif cmd == 'diffbkp':
    # printer("-c DiffBkp [-n nickname/servername] [-b backupid] -w where")
    if '-b' not in options.keys():
        options['-b']=None
    if '-w' not in options.keys():
        options['-w']=None
    cmd_diffbkp(nick,options['-b'],options['-w'],debug=debug)
elif cmd == 'restore':
    # printer("-c Restore [-n nickname/servername] [-b backupid/last] -f file2get -w where")
    if '-b' not in options.keys() or 'last' in options['-b']:
        options['-b']=None
    if '-f' not in options.keys():
        usage(cmd)
    if '-w' not in options.keys():
        usage(cmd)
    cmd_resto(nick,options['-b'],options['-f'],options['-w'],debug=debug)
elif cmd == 'delbkp':
    # printer("   -c DelBkp [-n nickname/servername] -b backupid")
    if '-b' not in options.keys() or 'last' in options['-b']:
        usage(cmd)
    cmd_delbkp(nick,options['-b'],debug=debug)
elif cmd == 'bkp':
    # printer("   -c Bkp [-n nickname/servername]")
    cmd_bkp(nick,debug=debug)
elif cmd == 'prune':
    # printer("   -c Prune [-n nickname/servername]")
    cmd_prune(nick,debug=debug)
else:
    printer("Mais comment on peut en arriver la ?")
    usage()