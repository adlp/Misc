#!/usr/bin/env python3

#/*
#* borgHelper to help you calling borg
#* Copyright (C) 2024 Antoine DELAPORTE
#*
#* This program is free software: you can redistribute it and/or modify
#* it under the terms of the GNU General Public License as published by
#* the Free Software Foundation, either version 3 of the License, or
#* (at your option) any later version.
#*
#* This program is distributed in the hope that it will be useful,
#* but WITHOUT ANY WARRANTY; without even the implied warranty of
#* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#* GNU General Public License for more details.
#*
#* You should have received a copy of the GNU General Public License
#* along with this program.  If not, see <http://www.gnu.org/licenses/>.
#*/

import getopt,sys,os
import socket
import configparser
import subprocess,select
import json

### Notes
# repo01 a cfg dans ~root/.ssh/config
# sshd distant a cfg pour permettre le sendEnv
# sur le repo01 poser la clef du serveur

cfgfile=os.path.expanduser("~/.borghelperrc")

Version="0.27.5"
### TODO Mieux gerer les sorties d'erreure de borg (si pas tout les parametres)
### TODO Mieux gerer les parametres "manquant" du borgrc (mountpoint)
### TODO Mieux aider la creation du borgrc
### TODO Mieux gerer le repertoire d'appel du programme (clause where) : elle n'est necessaire qu'au restore
### TODO Rajouter dans le diff au b l'option d'une virgule, afin de choisir sur quoi on fait le diff
### TODO Verifier l'etat de toutes les docs
### TODO Rajouter de quoi trouver les caches, et nettoyer ceux si
# 0.27.5 tracking des fichiers de cache
# 0.27.4 recuperation sur erreur de borg dans boex
# 0.27.3 html report are made, not finish but made, not fi....
# 0.27.2 report, more stable
# 0.27.1 now report multi host
# 0.27 report, it's working !! :)... report, the true bengining !
# 0.26 borghelperrc, is no more hard coded :) (yipii)
# 0.25 Now Login is used (for sto), correct a bug for some return
# 0.24 License Header
# 0.23 Tout plein de correctifs pour faire marcher les backups cf 0.20
# 0.22 Integration d'init pour initialiser un repo (local)
# 0.21 Corrrections due a l'integration de BORG_ROOTBKP BORG_ARCHNAME (0.20)
# 0.20 rajout de BORG_ARCHNAME et BORG_ROOTBKP afin de changer les noms des archives, et choisir une zone spé de backup...
# 0.19 Extend la doc, changement de certaines docs pour que ca passe ds la version ulterieur de python.. risque de pb d'utf8, mais python 3 est par defaut en utf8...
# 0.18   Prise en compte des plantage de borg sans le moindre stdout
# 0.17.3 Retire la variable ret pour la petite prune
# 0.17.2 Bug corrige pour les backup... en esperant que pour le reste ca soit green (car la on pallie aux cochonneries de borg himself)
# 0.17.1 Bug en cours sur le stderr
# 0.17 Refactoring code cf boex... a refaire login/reporting. Maintenant les retour des bkp ne partiront plus forcement en erreure si ce n'est que du Warning)
# 0.16.1 pousse sur disque les retours de sauvegarde et en stdout/stderr
# 0.16 pousse sur disque les retours de sauvegarde
# 0.15.1 True cache
# 0.15 Cache v1
# 0.14 boexec renvoie un dico stdout/stderr... et cela est pris en compte hein...
# 0.13.1 debug du diff qui suite aux evo ne marchait plus correctement en mode supra simpliste...
# 0.13 debug de l'affichage des report (lorsque l'avail n'est pas lisible)
# 0.12 on peut ne pas avoir la var SSH_REMFO
# 0.11 Possibilite de choisir la clef ssh
# 0.10 Prise en compte d'une liste "d'exclusion compltementarire"
# 0.9 Maintenant on peut faire un diff entre 2 archives specifies
# 0.8.3 meilleure gestion interne du rapport (pour facilitee les differentes sorties et les concatenations)
# 0.8.2 un rapport prettygoooood
# 0.8.1 un rapport plus fin
# 0.8 1er rapport
# 0.7.1 flushing 4 print 2 screen
# 0.6 prise en compte des backup locaux
# 0.5 Correction : on ne force plus le chemin d'execution tout le temps a /tmp
# 0.5 Et la petite prune est la yeaaah
# 0.4 On rajoute le backup
# 0.3 Rajout d'un helper pour deleter une sauvegarde precise
# 0.2.1 Semblerait que le diff soit inverse
# 0.2 Maintenant on peiut faire un diff entre les 2 dernieres versions (en precisant rien)
# 0.1 Premiere version (officielle) qui reagit bien a toutes les commandes

def version():
    print(f"Version {Version}")
    sys.exit(0)

def usage(doc=None,debug=0):
    if doc is None:
        printer("   -H <Stats|Login|Mount|UMount|ListBkp|ListBkpFiles|Restore>")
        printer("       Permet d'avoir les documentations detaillés des differentes commandes")
        printer("   -c Stats [-n server-name/nickname]")
        printer("       Liste les backup references, et le fait qu'ils soient mount ou pas")
        printer("   -c Login [-s servername] [-n nickname] [-k keyfile.key] -p passphrase -r repo -m mountpoint")
        printer("       n se log sur le serveur, utilise que si le serveur n'est pas referencé")
        printer("   -c <Mount|UMount> [-n nickname/servername]")
        printer("       On monte et on demonte le FS (BIEN Penser a demonter !!!)")
        printer("   -c LstBkp [-n nickname/servername]")
        printer("       On liste les backup connus")
        printer("   -c LstBkpFls [-n nickname/servername] [-b backupid/last]")
        printer("       On liste les fichiers d'un backup precis")
        printer("⚗️  -c Report [-n nickname/servername] [-b backupid/last] [-l]")
        printer("       Rapport sur le dernier (ou pas) backup, avec sortie en htmL")
        printer("   -c DiffBkp [-n nickname/servername] [-b backupid] [-w where]")
        printer("       Liste les mouvements des fichiers entre le backupid et le dernier backup")
        printer("   -c Restore [-n nickname/servername] [-b backupid/last] -f file2get -w where")
        printer("       On lance la restauration")
        printer("⚡️ -c DelBkp [-n nickname/servername] -b backupid")
        printer("       ⚡️ On delete un backup sur le repo ⚡️ DANGER")
        printer("   -c Init [-n nickname/servername]")
        printer("       Initialisation d'un repInitialisation d'un repoo")
        printer("   -c Bkp [-n nickname/servername]")
        printer("       On lance un backup")
        printer("⚗️ ⚡️-c Prune [-n nickname/servername]")
        printer("      ⚡️ On delete les vieux backup sur le repo ⚡️ DANGER")
    elif doc == 'stats':
        printer("   -c Stats [-n server-name/nickname]")
        printer("       Affiche toutes les informations des serveurs connus")
        printer("           Sans parametre listera tout")
        printer("           Avec parametre donnera le detail d'un serveur")
    elif doc == 'login':
        printer("   -c Login [-s servername] [-n nickname] [-k keyfile.key] -p passphrase -r repo")
        printer("       Integre le serveur dans borgHelper")
        printer("           servername  : le nom du serveur, sert de filtre pour lister les backups, sinon srv local")
        printer("           nickname    : nom apparant du serveur, permet pour un  serveur d'avoir plusieur repo")
        printer("           keyfile     : le fichier de clefs")
        printer("           passpharse  : le mot de passe d'acces au repo")
        printer("           repo        : l'addresse du repo")
    elif doc == 'mount':
        printer("   -c Mount [-n nickname/servername]")
        printer("       Rend accessible les sauvegarde dans un repertoire visible via la commande Stat ou affiche en fin de mount")
        printer("       A utiliser rarement, car tant que le repo est monté, on ne peut plus backuper")
        printer("           si -n non precisé alores on travaille avec le serveur courant")
        printer("           nickname    : Le nom de l'enregistrement du serveur")
    elif doc == 'umount':
        printer("   -c UMount [-n nickname/servername]")
        printer("       Coupe cet acces")
        printer("           si -n non precisé alores on travaille avec le serveur courant")
        printer("           nickname    : Le nom de l'enregistrement du serveur")
    elif doc == 'lstbkp':
        printer("   -c ListBkp [-n nickname/servername]")
        printer("       Liste les backup (backupid) disponibles")
        printer("           si -n non precisé alores on travaille avec le serveur courant")
        printer("           nickname    : Le nom de l'enregistrement du serveur")
    elif doc == 'listbkpfls':
        printer("   -c LstBkpFls [-n nickname/servername] -b backupid")
        printer("       Liste les fichiers disponibles dans le backup backupid")
        printer("           si -n non precisé alores on travaille avec le serveur courant")
        printer("           nickname    : Le nom de l'enregistrement du serveur")
        printer("           backupid    : Le nom du backup interessant")
    elif doc == 'report':
        printer("   -c Report [-n nickname/servername] [-b backupid/last]")
        printer("       Rapport sur le dernier (ou pas) backup")
        printer("   ⚗️i DEV VERSION")
    elif doc == 'diffbkp':
        printer("   -c DiffBkp [-n nickname/servername] -b backupid [-w where]")
        printer("       Liste les mouvements des fichiers entre le backupid et le dernier backup")
        printer("           backupid    : Le nom du backup interessant (si pas precisé compare les 2 derniers)")
        printer("           where       : Repertoire de filtre")
    elif doc == 'restore':
        printer("   -c Restore [-n nickname/servername] -b backupid -f file2get -w where")
        printer("       Restaure l'arbo (ou fichier) file2berestored depuis le backup backupid dans l'emplacement where")
        printer("           si -n non precisé alores on travaille avec le serveur courant")
        printer("           nickname    : Le nom de l'enregistrement du serveur")
        printer("           backupid    : Le nom du backup interessant")
        printer("           file2get    : Le nom du fichier ou de l'arbo a recuperer")
        printer("           where       : Repertoire de restauration")
    elif doc == 'delbkp':
        printer("   -c DelBkp [-n nickname/servername] -b backupid")
        printer("       ⚡️ On delete un backup sur le repo ⚡️ DANGER")
        printer("       nickname    : Le nom de l'enregistrement du serveur")
        printer("       backupid    : Le nom du backup interessant")
    elif doc == 'bkp':
        printer("   -c Bkp [-n nickname/servername]")
        printer("       On lance un backup")
        printer("       Lance le backup en temps reel (utilisé par les crontabs pex), avec les parametres du fichier de conf")
    elif doc == 'prune':
        printer("   -c Prune [-n nickname/servername]")
        printer("      ⚡️ On delete les vieux backup sur le repo ⚡️ DANGER")
        printer("   ⚗️i DEV VERSION")
    elif doc == 'init':
        printer('   -c init [-n nickname/servername]')
        printer('      Initiaslisation du repo')
    else:
        printer(f"  Desole pas de documation pour la commande {doc}")

    sys.exit(1)

def printer(data,debug=0):
    print(data,file=sys.stderr)

def cfgread(nick,debug=0):
    #BORG_REPO #BORG_PASSPHRASE #BORG_RELOCATED_REPO_ACCESS_IS_OK
    #GLOB_ARCH #SER_NAME #NICK
    if os.path.exists(cfgfile) and os.path.isfile(cfgfile):
        config= configparser.ConfigParser()   
        config.optionxform=str
        config.read(cfgfile)
        if nick not in config.keys():
            return(None)
        else:
            #pretab={}
            #for i in config[nick].keys():
            #    printer(i)
            #    printer(config[nick][i])
            #    pretab[i]=config[nick][i]
            #printer("show must go on")
            #return(pretab)
            return(config[nick])
    else:
        return(None)

def cfgreaded(nick,debug=0):
    cfg=cfgread(nick,debug=debug)
    if cfg is None:
        printer("Ce serveur est inconnu")
        sys.exit(3)
    return(cfg)

def cfgwrite(nick,serna,passphrase,repo,mountpoint,debug=0):
    config= configparser.ConfigParser()
    config.optionxform=str
    config.read(cfgfile)

    config[nick]={}
    config[nick]['BORG_REPO']=repo
    config[nick]['BORG_PASSPHRASE']=passphrase
    config[nick]['SER_NAME']=serna
    config[nick]['GLOB_ARCH']=serna+'-root-*'
    if mountpoint is None:
        config[nick]['MOUNTPOINT']="/mnt/borg/"+nick
    else:
        config[nick]['MOUNTPOINT']=mountpoint

    with open(cfgfile, 'w') as fd:
        config.write(fd)
        fd.close()

def convert_octets_readable(size_in_bytes,sib=1000):
    suffixes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']
    index = 0

    while size_in_bytes >= sib and index < len(suffixes) - 1:
        size_in_bytes /= sib
        index += 1

    # Formatage avec deux chiffres après la virgule
    return f"{size_in_bytes:.2f} {suffixes[index]}"

def affconf(nick):
    cfg=cfgreaded(nick)
    print(nick+': ',end='')
    if mountedornot(cfg['MOUNTPOINT'],debug=debug):
        print('**Mounted**')
    else:
        print('Not Mounted')
#    for i in cfg.keys():
#        print(f"  {i}={cfg[i]}")
    
def cmd_stats(nick=None,debug=0):
    if os.path.exists(cfgfile) and os.path.isfile(cfgfile):
        config= configparser.ConfigParser()   
        config.optionxform=str
        config.read(cfgfile)
        if nick is None:
            for n in config.keys():
                if n in 'DEFAULT':
                    continue
                affconf(n)
        elif nick in config.keys():
            affconf(nick)
        else:
            print(f'{nick} pas trouvé dans {cfgfile}')
            sys.exit(1)
    else:
        printer(f'Fichier {cfgfile} absent')
        sys.exit(2)


def cmd_login(serna,nick,keyfile,passphrase,repo,mountpoint,debug=0):
    cfgwrite(nick,serna,passphrase,repo,mountpoint,debug=debug)
    cfg=cfgread(nick,debug=debug)
    if keyfile is not None:
        if os.path.exists(keyfile) and os.path.isfile(keyfile):
            rb=boex(nick,['key','import',repo,keyfile],debug=debug)
            print(rb)
            sys.exit(rb['exitcode'])
        else:
            printer("Fichier "+keyfile+" absent, Mais attention, machine "+nick+" integre")
            sys.exit(2)

def mountedornot(mountpoint,debug=0):
    founded=False
    if debug:
        printer(f' On control {mountpoint}')
    with open('/proc/mounts') as fd:
        while (line := fd.readline()) and not founded:
            if mountpoint in line:
                founded=True
        fd.close()
    return(founded)

def cmd_mount(nick,debug=0):
    cfg=cfgreaded(nick)

    if os.path.exists(cfg['MOUNTPOINT']) and os.path.isdir(cfg['MOUNTPOINT']) and len(os.listdir(cfg['MOUNTPOINT'])) == 0:
        if(not mountedornot(cfg['MOUNTPOINT'],debug=debug)):
            rb=boex(nick,['mount','--glob-archives',cfg['GLOB_ARCH'],cfg['BORG_REPO'],cfg['MOUNTPOINT']],debug=debug)
            print(rb)
            sys.exit(rb['exitcode'])
        else:
            printer('Deja monte')
            sys.exit(3)
    else:
        printer("Il faut que le repertoire "+cfg['MOUNTPOINT']+" existe et soit vide!")
        sys.exit(2)

def cmd_umount(nick,debug=0):
    cfg=cfgreaded(nick,debug=debug)
    if(mountedornot(cfg['MOUNTPOINT'],debug=debug)):
        rb=boex(nick,['umount',cfg['MOUNTPOINT']],debug=debug)
        print(rb)
        sys.exit(rb['exitcode'])
    else:
        printer('Pas monte')
        sys.exit(3)

def cmd_lstbkp(nick,debug=0):
    cfg=cfgreaded(nick,debug=debug)
    rb=boex(nick,['list','--json','--glob-archives',cfg['GLOB_ARCH']],debug=debug)
    for i in rb['stdout'][0]['archives']:
        print(f"{i['name']} {i['start']}")
    sys.exit(rb['exitcode'])

def getlastbkp(nick,nbl=1,debug=0):
    cfg=cfgreaded(nick,debug=debug)
    rb=boex(nick,['list','--json','--glob-archives',cfg['GLOB_ARCH']],debug=debug)
    #lines=boex(nick,['list','--glob-archives',cfg['GLOB_ARCH']],ret=True,debug=debug)['stdout']
    lines=rb['stdout'][0]['archives']
    ret=[]
    for i in range(nbl*-1,0):
        #ret.append(lines[i].split(' ')[0])
        ret.append(lines[i]['name'])
    return(ret)
    #return(lines[-1].split(' ')[0])

def cmd_lstfiles(nick,bid,debug=0):
    cfg=cfgreaded(nick,debug=debug)
    if bid is None:
        bid=getlastbkp(nick,debug=debug)[0]
    #rb=boex(nick,['list','--json','--glob-archives',cfg['GLOB_ARCH'],'::'+bid],debug=debug)
    rb=boex(nick,['list','--glob-archives',cfg['GLOB_ARCH'],'::'+bid],debug=0)
    for i in rb['stdout']:
        print(i)
    sys.exit(rb['exitcode'])

def cacheJsonBoexWithLM(nick,boexarg,prefix="/tmp/borgHelper-",suffix=".json",output="stdout",debug=0):
    last_modified=boex(nick,['info','--json'],debug=debug)['stdout'][0]['repository']['last_modified']
    nomFi=prefix+nick+'-'+last_modified+suffix
    if os.path.isfile(nomFi):
        if debug:
            printer("Use cache "+nomFi)
        caTxt=""
        with open(nomFi,'r') as fd:
            for line in fd:
                caTxt+=line
            fd.close()
        ret=json.loads(caTxt)
    else:
        if debug:
            printer("Create cache")
        ret=boex(nick,boexarg,debug=debug)[output][0]
        with open(nomFi,"w") as fd:
            print(json.dumps(ret,indent=4),file=fd)
            fd.close()
    #Quand on en est la, ca ne sent pas bon
    if type(ret) is list:
        return(ret[0])
    else:
        return(ret)
    

def prep_report(nick,debug=0,maxp=None):
    import re
    cfg=cfgreaded(nick,debug=debug)
    pruneme=[]
    for i in cmd_prune(nick,dryrun=True,debug=debug):
        if 'Would prune:' in i:
            pruneme.append(((re.sub(r'( )*',r'\1',i)).split(' '))[2])

    #r=json.loads('\n'.join(boex(nick,['info','--json','--glob-archives',cfg['GLOB_ARCH']],ret=True,debug=debug)['stdout']))
    r=cacheJsonBoexWithLM(nick,['info','--json','--glob-archives',cfg['GLOB_ARCH']],suffix="-info.json",debug=debug)

    resume={}
    resume['duration']=0
    for i in ['duration','compressed_size','deduplicated_size','nfiles','original_size','prunable','prunable_os','prunable_cs']:
        resume[i]=0

    c=0
    kept={}
    notPrunable=0
    for i in r['archives']:
        resume['duration']+=i['duration']
        resume['compressed_size']+=i['stats']['compressed_size']
        resume['deduplicated_size']+=i['stats']['deduplicated_size']
        resume['original_size']+=i['stats']['original_size']
        resume['nfiles']+=i['stats']['nfiles']

        i['command_line']=[]
        i['chunker_params']=[]
        kept[i['name']]={}
        kept[i['name']]['name']             =i['name']
        kept[i['name']]['durationM']        =i['duration']/60
        kept[i['name']]['original_size']    =i['stats']['original_size']
        kept[i['name']]['compressed_size']  =i['stats']['compressed_size']
        kept[i['name']]['deduplicated_size']=i['stats']['deduplicated_size']
        kept[i['name']]['nfiles']           =i['stats']['nfiles']
        
        if i['name'] in pruneme:
            i['pruneMe']='Yes'
            kept[i['name']]['prunMe']='Yes'
            resume['prunable']+=i['stats']['deduplicated_size']
            resume['prunable_os']+=i['stats']['original_size']
            resume['prunable_cs']+=i['stats']['compressed_size']
        else:
            i['pruneMe']='No'
            kept[i['name']]['prunMe']='No'
            notPrunable+=1
        c+=1

    resume['moy_duration']=resume['duration']/c
    resume['unique_csize']=r['cache']['stats']['unique_csize']
    for i in ['duration','compressed_size','deduplicated_size','nfiles','original_size','unique_csize']:
        resume['moy_'+i]=resume[i]/c


    resume['total_size']=r['cache']['stats']['total_size']
    resume['total_csize']=r['cache']['stats']['total_csize']

    resume['last']=r['archives'][c-1]['start']
    resume['lastname']=r['archives'][c-1]['name']

    if debug > 0:
        print(json.dumps(r,indent=4))
        print(json.dumps(resume,indent=4))
        print(json.dumps(kept,indent=4))

    avail=dfRepo(nick)
    dabesi=d2DateNSince(resume['last'])

    tcmpl={}
    tcmpl[nick]={}
    #tcmpl[nick]['nom']          =cfg['SER_NAME']
    tcmpl[nick]['nom']          =nick
    tcmpl[nick]['date derniere']=dabesi["date"]
    tcmpl[nick]['depuis']       =dabesi['since']
    tcmpl[nick]['duree']        =kept[resume['lastname']]['durationM']
    tcmpl[nick]['derniere']     =kept[resume['lastname']]['deduplicated_size']
    tcmpl[nick]['moy']          =resume['moy_deduplicated_size']
    tcmpl[nick]['taille']       =resume['unique_csize']
    tcmpl[nick]['recuperable']  =resume['prunable']
    tcmpl[nick]['reste']        =avail

    tbkps={}
    tbkps['Prunable']={}
    tbkps['Prunable']['name']               ='Prunable'
    tbkps['Prunable']['original_size']      =resume['prunable_os']
    tbkps['Prunable']['compressed_size']    =resume['prunable_cs']
    tbkps['Prunable']['deduplicated_size']  =resume['prunable']
    
    cpt=0
    for i in kept.keys():
        if kept[i]['prunMe'] == 'No':
            if (maxp is None) or ((notPrunable - cpt ) <= maxp):
                tbkps[i]=kept[i]
                tbkps[i]['duration']=kept[i]['durationM']
                tbkps[i].pop('durationM')
                tbkps[i].pop('prunMe')
            cpt+=1
    tbkps['All']={}
    tbkps['All']['name']='All'
    tbkps['All']['original_size']       =resume['total_size']
    tbkps['All']['compressed_size']     =resume['total_csize']
    tbkps['All']['deduplicated_size']   =resume['unique_csize']

    return(tcmpl,tbkps)

def cmd_report(nicks,htrep=False,dayback=None,debug=0,maxp=None):
    reshos={}
    resbck={}
    reshosto={}
    for i in ['duree','derniere','taille','recuperable']:
        reshosto[i]=0
    reshosto['nom']='Totaux'
    for nick in nicks.split(','):
        (tcmpl,tbkps)=prep_report(nick,debug=debug,maxp=maxp)
    
        for i in ['duree','derniere','taille','recuperable']:
            reshosto[i]+=tcmpl[nick][i]
        for i in ['derniere','moy','taille','recuperable','reste']:
            if (i in tcmpl[nick].keys()) and not(tcmpl[nick][i] is  None):
                tcmpl[nick][i]=convert_octets_readable(tcmpl[nick][i])
            else:
                tcmpl[nick][i]=""
        tcmpl[nick]['depuis']=f"{tcmpl[nick]['depuis']:.2f} h"
        tcmpl[nick]['duree']=f"{tcmpl[nick]['duree']:.2f} min"
        for i in tbkps.keys():
            for j in ['original_size','compressed_size','deduplicated_size']:
                tbkps[i][j]=convert_octets_readable(tbkps[i][j])
            if 'duration' in tbkps[i].keys():
                tbkps[i]['duration']=f"{tbkps[i]['duration']:.2f} min"
        reshos[nick]=tcmpl[nick]
        resbck[nick]=tbkps
    for i in ['derniere','taille','recuperable']:
        reshosto[i]=convert_octets_readable(reshosto[i])
    reshosto['duree']=f"{reshosto['duree']:.2f} min"
    reshos['Totaux']=reshosto
    if htrep:
        print("<!DOCTYPE html>")
        print("<html>")
        print('  <body bgcolor="#ffffff">')
        print("    <br>")
        print(htmlTabelise(reshos,colnames=['nom','duree','depuis','derniere','taille','recuperable','reste']))
        print('  </body>')
        print('</html>')
        for nick in nicks.split(','):
            print(htmlTabelise(resbck[nick],colnames=['name','duration','original_size','compressed_size','deduplicated_size','nfiles']))
    else:
        print(prettyTabelise(reshos))
        for nick in nicks.split(','):
            print(prettyTabelise(resbck[nick]))

def d2DateNSince(datepourrie):
    from datetime import datetime
    from time import gmtime,mktime

    forPour     = "%Y-%m-%dT%H:%M:%S.%f"
    now         = datetime.fromtimestamp(mktime(gmtime()))
    now         = datetime.now()
    datelisible = datetime.strptime(datepourrie, forPour)
    since       = (now - datelisible).total_seconds() / 60 / 60

    forNew      = "%Y/%m/%d %H:%M:%S"
    newstart    = datelisible.strftime(forNew)

    return({'since':since, 'date':newstart})

def prettyTabelise(tab):
    from prettytable import PrettyTable
    # https://pypi.org/project/prettytable/

    clefs={}
    serrure=0
    for i in tab.keys():
        for j in tab[i].keys():
            if j not in clefs.keys():
                clefs[j]=serrure
                serrure+=1
    t=PrettyTable(clefs.keys())
    for i in tab.keys():
        liste=[]
        for j in clefs:
            if j not in tab[i]:
                liste.append("")
            else:
                liste.append(tab[i][j])
        t.add_row(liste)
    return(t)

def htmlTabelise(tabl,border=0,colnames=None):
    ret=""
    ret+="<table border='0'>\n  <tr>\n"
    # Generation du tableau pour les titres
    if colnames == None:
        colnames=[]
        for y in tabl.keys(): # On cherche ds tout les elements
            for x in tabl[y].keys():   # On pecho la clef, car ca c'est de la bonne
                colnames.append(x)
    for x in colnames:
        ret+=f"    <td colspan=1>{x}</td><td style='width:20px;'></td>\n"
    ret+="    </tr>\n"
    for y in tabl.keys():
        ret+='  <tr>\n'
        for x in colnames:
            val=""
            if x in tabl[y].keys():
                val=tabl[y][x]
            ret+=f"    <td colspan=1>{val}</td><td style='width:20px;'></td>\n"
        ret+='    </tr>\n'
    ret+='</table>\n'
    return(ret)

def dfRepo(nick,debug=0):
    cfg=cfgreaded(nick,debug=debug)

    if ':' not in cfg['BORG_REPO']:
        process = subprocess.Popen(f'df { cfg["BORG_REPO"] } --output=avail | tail -1 ', stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
        stdout, stderr = process.communicate()
    else:
        return None

    if debug:
        stderr(stdout.decode('utf-8'))
        stderr(stdout.decode('utf-8').split(" ")[-1])
    # Vérifie si l'exécution a réussi
    if process.returncode == 0:
        return int(stdout.decode('utf-8').split(" ")[-1])*1024
    return None


def cmd_diffbkp(nick,bidun=None,bideux=None,debug=0):
    cfg=cfgreaded(nick,debug=debug)
    twodiff=getlastbkp(nick,2,debug=debug)
    if bidun is None and bideux is None:
        bidun=twodiff[0]
        bideux=twodiff[1]
    elif bideux is None:
        bideux=bidun
        bidun=twodiff[1]
    if bidun == bideux:
        printer("Desole, ce sont les memes backups")
        sys.exit(1)

    if debug:
        printer(f"Compraison de {bidun} et {bideux}")
        printer(twodiff)

    if bidun > bideux:
        bid=bideux
        bideux=bidun
        bidun=bid

    arg=['diff',f"{cfg['BORG_REPO']}::{bidun}", bideux]

    rb=boex(nick,arg,debug=debug,retjson=False)
    for i in rb['stdout']:
        print(i)
    sys.exit(rb['exitcode'])

def cmd_resto(nick,bid,ftor,where,debug=0):
    cfg=cfgreaded(nick,debug=debug)
    if bid is None:
        bid=getlastbkp(nick,debug=debug)[0]
    rb=boex(nick,['extract','--exclude','*/log/*','::'+bid,ftor],rep=where,debug=debug)
    print(rb)
    sys.exit(rb['exitcode'])

def cmd_delbkp(nick,bid,debug=0):
    cfg=cfgreaded(nick,debug=debug)
    rb=boex(nick,['delete','::'+bid],debug=debug)
    if rb['exitcode'] != 0:
        print(rb)
        sys.exit(rb['exitcode'])
    boex(nick,['compact','--cleanup-commits'],debug=debug)
    if rb['exitcode'] != 0:
        print(rb)
    sys.exit(rb['exitcode'])


def cmd_prune(nick,dryrun=False,debug=0):
    cfg=cfgreaded(nick,debug=debug)
    cmd=['prune']
    for i in list(cfg.keys()):
        if 'KEEP_DAILY' == i:
            cmd.append('--keep-daily')
            cmd.append(cfg[i])
        elif 'KEEP_WEEKLY' == i:
            cmd.append('--keep-weekly')
            cmd.append(cfg[i])
        elif 'KEEP_MONTHLY' == i:
            cmd.append('--keep-monthly')
            cmd.append(cfg[i])
        elif 'KEEP_YEARLY' == i:
            cmd.append('--keep-yearly')
            cmd.append(cfg[i])
        elif 'KEEP_HOURLY' == i:
            cmd.append('--keep-hourly')
            cmd.append(cfg[i])

    if len(cmd) >1:
        # BORG_PASSPHRASE=$pass borg prune --keep-daily 31 --save-space --info --list --stats --glob-archives="$arcg-*" $repo
        if dryrun:
            cmd.append('--dry-run')
        else:
            cmd.append('--stats')
        cmd.extend(f'--save-space --info --list --glob-archives={cfg["GLOB_ARCH"]}'.split(' '))
        ret=boex(nick,cmd,debug=debug)['stderr']
        if not dryrun:
            rb=boex(nick,['compact','--cleanup-commits'],debug=debug)
            print(rb)
            sys.exit(rb['exitcode'])
        else:
            return(ret)
    else:
        usage('prune')

def cmd_init(nick,debug=0):
    cfg=cfgreaded(nick,debug=debug)

    cmd=[]
    # borg init --encryption repokey /path/to/repo
    cmd.extend("init --encryption repokey".split(' '))
    ret=boex(nick,cmd,debug=debug)
    print(ret)

def cmd_bkp(nick,debug=0):
    cfg=cfgreaded(nick,debug=debug)

###    SetEnv BORG_PASSPHRASE=XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX BORG_REPO=repo01:/mnt/borg03/sxb-03
### Ce qui change par rapport a un vrai boex
###    Variable env BORG_REPO reecrite
###    Precedence du ssh
###
###    cmda=f"ssh -Ao StrictHostKeyChecking=no -o LogLevel=ERROR -o UserKnownHostsFile=/dev/null {host} 'borg create --log-json --json --debug -v --stats "
###    cmdb="::{fqdn}-root-{now} / --exclude /media --exclude /dev --exclude /proc --exclude /sys --exclude /var/run --exclude /run --exclude /lost+found --exclude /mnt --exclude /var/lib/lxcfs --exclude /tmp --exclude /var/lib/docker --exclude-if-present .nobackup  --exclude-caches --exclude-nodump --keep-exclude-tags'"

### Ce qu'il faut faire
###     1. Stocker les ordres d'exclusion du backup (le reste sera pour le moment hardcodé)
###     2. Preceder la commande du backup ssh proprement (avec enregistrement de la clef)
###     3. Traiter les codes retours
    if 'SSH_REPO' in cfg.keys():
        forceEnv={}
        forceEnv['BORG_REPO']=cfg['SSH_REPO']
    else:
        forceEnv=None

    preBorg=['ssh','-o','SendEnv BORG_*']
    if 'SSH_REMFO' in cfg.keys():
        preBorg.append('-R')
        preBorg.append(cfg['SSH_REMFO'])
    preBorg.extend(f'-A -o VisualHostKey=no -o StrictHostKeyChecking=accept-new {cfg["SER_LOGIN"]}@{cfg["SER_NAME"]}'.split(' '))
    if 'SSH_KEY' in cfg.keys():
        preBorg.append('-i')
        preBorg.append(cfg['SSH_KEY'])
    if 'SSH_REMFO' not in cfg.keys() or len(cfg['SSH_REMFO']) == 0:
        preBorg=None

    create=['create']
    #create.extend(('--log-json --json --debug -v --stats '+cfg['BORG_REPO']+'::{fqdn}-root-{now} /').split(' '))
    #create.extend(('--log-json --json --debug -v --stats ::{fqdn}-root-{now} /').split(' '))
    create.extend(('--log-json --json --debug -v --stats').split(' '))
    archname='root'
    if 'BORG_ARCHNAME' in cfg.keys():
        archname=cfg['BORG_ARCHNAME']
    create.append('::{fqdn}-'+archname+'-{now}')

    rootbkp="/"
    if 'BORG_ROOTBKP' in cfg.keys():
        rootbkp=cfg['BORG_ROOTBKP']
    create.append(rootbkp)
        
    if 'EXCLUDE' not in list(cfg.keys()):
        printer(list(cfg.keys()))
        printer("Il est necessaire que EXCLUDE soit configures dans ~/.borghelperrc")
        printer('  EXCLUDE = --exclude /media --exclude /dev --exclude /proc --exclude /sys --exclude /var/run --exclude /run --exclude /lost+found --exclude /mnt --exclude /var/lib/lxcfs --exclude /tmp --exclude /var/lib/docker --exclude-if-present .nobackup  --exclude-caches --exclude-nodump --keep-exclude-tags')
        exit(1)
    create.extend(cfg['EXCLUDE'].split(' '))
    if 'EXCLUDE_NEXT' in list(cfg.keys()):
        create.extend(cfg['EXCLUDE_NEXT'].split(' '))

    nomFi=f"/tmp/borgHelper-bkp-{nick}.json"
    anaRet=boex(nick,create,preBorg=preBorg,forceEnv=forceEnv,debug=debug)
    with open(nomFi,"w") as fd:
        print(json.dumps(anaRet,indent=4),file=fd)
        fd.close()

    if 'stdout' in anaRet.keys() and len(anaRet['stdout']):
        print(json.dumps(anaRet['stdout'][0],indent=4),file=sys.stdout,flush=True)
    else:
        print("")
    if 'stderr' in anaRet.keys():
        print(json.dumps(anaRet['stderr'],indent=4),file=sys.stderr,flush=True)
        print("")

    newretC=0
    if anaRet['exitcode']:
        for i in (anaRet['stderr']):
            if debug:
                printer(i)
            if type(i) != str and i['levelname'] == "ERROR":
                newretC=2

    sys.exit(newretC)

def cmd_poc(nick,debug=0):
    nomFi=f"/tmp/borgHelper-bkp-{nick}.json"
    caTxt=""
    with open(nomFi,'r') as fd:
        for line in fd:
            caTxt+=line #.replace('"',"'")
        fd.close()
    ret=json.loads(caTxt)
    #pouff=json.loads('\n'.join(ret['stderr']))
    #print(json.dumps(pouff,indent=4))
    #print(json.dumps(ret['stderr'][1],indent=4))
    #print(ret['stderr'])
    #print(json.dumps(ret,indent=4))


def boex(nick,arg,rep=None,debug=0,preBorg=None,forceEnv=None,retjson=True): #,getStdErr=False):
    cfg=cfgreaded(nick,debug=debug)
    varcur=os.environ.copy()
    varfut={}
    if debug != 0:
        printer('Boex the first')
    for k in list(cfg.keys()):
        if k in ['BORG_REPO','BORG_PASSPHRASE','BORG_REMOTE_PATH','BORG_RSH','BORG_SHOW_SYSINFO','BORG_RELOCATED_REPO_ACCESS_IS_OK']:
            varfut[k]=cfg[k]

    if forceEnv is not None:
        for k in list(forceEnv.keys()):
            varfut[k]=forceEnv[k]

    if debug != 0:
        printer(varfut)

    if preBorg is not None:
        commande=preBorg
        commande.append('borg')
    else:
        commande=['borg']

    if rep is None:
        rep=os.getcwd()
    commande.extend(arg)
    varfut['PATH']=varcur['PATH']
    if debug:
        for k in varfut:
            printer(f' {k}={varfut[k]}')
        printer(f"+{rep}")
        printer(commande)
        printer(f"{' '.join(commande)}")
        printer(f"+{rep} >{' '.join(commande)}")
        if arg[1] in "extract":
            sys.exit(4)
    ps=subprocess.Popen(commande,encoding ='utf-8',
                         env=varfut,cwd=rep,bufsize=8192,
                         stdin=subprocess.PIPE,
                         stdout=subprocess.PIPE,
                         stderr=subprocess.PIPE)
    inf, errs = ps.communicate()

    ret={}
    ret['stdout']=[]
    ret['stderr']=[]

    #if debug:
    #    printer('StdOut')
    #    printer(inf)
    #    printer('-----------------------------------------------------------------------')
    #    printer('StdErr')
    #    printer(type(errs))
    #    printer(errs)
    
    if(len(inf)):
        if inf[0] in '[{' and retjson:
            ret['stdout'].append(json.loads(inf))
        else:
            for i in inf.split('\n'):
                ret['stdout'].append(i)
    if(len(errs)):
        if errs[0] in '{':
            try:
                ret['stderr']=json.loads('['+','.join(errs.split('\n'))[:-1]+']')
            except:
                errs=errs.replace('"','_')
                ret['stderr']=json.loads('["'+errs+'"]')
        else:
            for i in errs.split('\n'):
                ret['stderr'].append(i)
    ret['exitcode']=ps.returncode

    if debug:
        printer(json.dumps(ret,indent=4))

    return(ret)

    #if ret:
    #    return({'stdout':''.join(inf).splitlines(), 'stderr': ''.join(errs).splitlines(),'exitcode': ps.returncode })
    #else:
    #    for line in inf:
    #        print(line,end='',flush=True)
    #    if len(errs):
    #        print(f'\n===================({ps.returncode})=======================================\n',flush=True)
    #        for line in errs:
    #            print(line,end="",flush=True)
   # 
   #     if ps.returncode != 0:
   #         sys.exit(ps.returncode)


######### Analyse Arguments

try:
    opts, args = getopt.getopt(sys.argv[1:],"c:hH:s:n:k:p:r:m:b:f:w:dvl", ["help"])
except getopt.GetoptError as err:
    print(err)  # will print something like "option -a not recognized"
    usage()
    sys.exit(2)

debug=0
cmd=None

optab={ 'stats'     :'cdn',      'login'     :'cdsnkprm',
        'mount'     :'cdn',      'umount'    :'cdn',
        'lstbkp'    :'cdn',      'lstbkpfls' :'cdnb',
        'restore'   :'cdnbfw',   'diffbkp'   :'cdnbw',
        'delbkp'    :'cdnb',     'bkp'       :'cdn',
        'prune'     :'cdn',      'report'    :'cdnbl',
        'init'      :'cdn',      'poc'       :'cdn',}

for opt,arg in opts:
    if   opt in '-h':
        usage()
    elif opt in '-H':
        usage(arg.lower())
    elif opt in '-c':
        cmd=arg.lower()
    elif opt in '-d':
        debug+=1
    elif opt in '-v':
        version()
        

if cmd is None or cmd not in optab.keys():
    usage()
# On part du principe que usage(xxx) quitte avec un exitcode

options={}
nick=socket.gethostname()

for opt,arg in opts:
    if opt[1] not in optab[cmd]:
        printer("step2"+opt[1])
        usage(cmd)
    else:
        options[opt]=arg
    if opt in '-n':
        nick=arg

if debug != 0:
    printer(f'La commande fume {cmd}')


#func_map= { stats:cmd_stats(nick,options.keys),
#            login:cmd_login(options.keys),
#            mount:cmd_login(nick),
#            umount:cmd_login(nick),
#            lstbkp:cmd_lstbkp(nick),
#            lstbkpfls:cmd_lstbkpfls(nick,options),
#            diffbkp:cmd_diffbkp(nick,options),
#            restore:cmd_restore(nick,options),
#           }
# func_map.get(cmd,usage)()

if   cmd == 'stats':
    if '-n' in options.keys():
        cmd_stats(nick)
    else:
        cmd_stats()
elif cmd == 'login':
    # TODO blocquer si mounted
    # printer("-c Login [-s servername] [-n nickname] [-k keyfile.key] -p passphrase -r repo")
    if '-s' not in options.keys():
        serna=socket.gethostname()
    else:
        serna=options['-s']
    if '-n' not in options.keys():
        nick=serna
    if '-k' not in options.keys():
        options['-k']=None
    if '-p' not in options.keys():
        printer('p')
        usage(cmd)
    if '-r' not in options.keys():
        printer('r')
        usage(cmd)
    if '-m' not in options.keys():
        options['-m']=None
    cmd_login(serna,nick,options['-k'],options['-p'],options['-r'],options['-m'],debug=debug)
elif cmd == 'mount':
    # printer("-c Mount [-n nickname/servername]")
    cmd_mount(nick,debug=debug)
elif cmd == 'umount':
    # printer("-c UMount [-n nickname/servername]")
    cmd_umount(nick,debug=debug)
elif cmd == 'lstbkp':
    # printer("-c LstBkp [-n nickname/servername]")
    cmd_lstbkp(nick,debug=debug)
elif cmd == 'lstbkpfls':
    # printer("-c LstBkpFls [-n nickname/servername] [-b backupid/last]")
    if '-b' not in options.keys() or 'last' in options['-b']:
        options['-b']=None
    cmd_lstfiles(nick,options['-b'],debug=debug)
elif cmd == 'report':
    # printer("   -c Report [-n nickname/servername] [-b backupid/last]")
    if '-b' not in options.keys() or 'last' in options['-b']:
        options['-b']=None
    else:
        options['-b']=int(options['-b'])
    if '-l' in options.keys():
        cmd_report(nick,htrep=True,maxp=options['-b'],debug=debug)
    else:
        cmd_report(nick,maxp=options['-b'],debug=debug)
elif cmd == 'diffbkp':
    # printer("-c DiffBkp [-n nickname/servername] [-b backupid] -w where")
    if '-b' not in options.keys():
        bidun=None
        bideux=None
    elif ',' in options['-b']:
        (bidun,bideux)=options['-b'].split(',',2)
    else:
        bidun=options['-b']
        bideux=None
    cmd_diffbkp(nick,bidun,bideux,debug=debug)
elif cmd == 'restore':
    # printer("-c Restore [-n nickname/servername] [-b backupid/last] -f file2get -w where")
    if '-b' not in options.keys() or 'last' in options['-b']:
        options['-b']=None
    if '-f' not in options.keys():
        usage(cmd)
    if '-w' not in options.keys():
        usage(cmd)
    cmd_resto(nick,options['-b'],options['-f'],options['-w'],debug=debug)
elif cmd == 'delbkp':
    # printer("   -c DelBkp [-n nickname/servername] -b backupid")
    if '-b' not in options.keys() or 'last' in options['-b']:
        usage(cmd)
    cmd_delbkp(nick,options['-b'],debug=debug)
elif cmd == 'bkp':
    # printer("   -c Bkp [-n nickname/servername]")
    cmd_bkp(nick,debug=debug)
elif cmd == 'prune':
    # printer("   -c Prune [-n nickname/servername]")
    cmd_prune(nick,debug=debug)
elif cmd == 'init':
    cmd_init(nick,debug=debug)
elif cmd == 'poc':
    cmd_poc(nick,debug=debug)
else:
    printer("Mais comment on peut en arriver la ?")
    usage()
