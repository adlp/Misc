#!/usr/bin/env python3

# Le programme ne doit rien faire si son stdin est vide (-S alors il petera quand emem son mail)
# Le programme doit gerener le in reply to si necessaire (-i blah)
# Le programme doit generer le sujet si necessaire (-s subject)
# Le programme doit envoyer a l'user executant  (-d email) LOGNAME
# on peut programmer le a qui con repond et le message id  ( -r / -m )
# ca peut etre lui le lanceur il n'est pas que piped Et ainsi on peut recuperer le stderr (-e '')

### Pour les version python anterieur a 3.6
### pip install future-fstrings
### -*- coding: future_fstrings -*-

import getopt,sys
import os
import hashlib
import subprocess
from datetime import datetime

Version="0.8.1"
### Todo un mode flush pour le tee
### Todo intercepter le keyboard interrupt
### Todo ajouter l'usage d'un fichier de donc mode@fichier => muodule mode du fichier fichier
### Todo rajouter header date debut + rajouter header de la commande (mais desativable par un flag)
# 0.9 New header : date debut execution/ commande lancee / exit code
# 0.8.1 On rajoute un header propre a cet outils sans la faute
# 0.7 On rajoute une notion de priorite
# 0.6 On jolieffie le from
# 0.5 en mode tee, on ne saute pas de lignes
# 0.4 Activation du X (no sub chg), Ajout du changement du from, Ajout du tee mode (dump en meme temps que mail le stdout et stderr)
# 0.3 Rajout du traitement des erreures
# 0.2 On rajoute le versionning a cronMutt
# 0.1  Un outils pour mieux gerer l'envoie des mails a partir des corns


def subprosend(cmd,datas):
    mutt=subprocess.Popen(cmd,encoding ='utf-8',
                         stdin=subprocess.PIPE,
                         stdout=subprocess.PIPE,
                         stderr=subprocess.PIPE)
    stdoutdata,stderrdata=mutt.communicate(input=datas)


def version():
    print(f"Version {Version}")
    sys.exit(0)

def usage():
    print("     E       Mail even empty data")
    print("     i:      in-reply-to")
    print("     s:      Mail subject")
    print("     d:      Destination email")
    print("     r:      ReplyTo")
    print("     f:      from (si different du reply to)")
    print("     m:      message id")
    print("     e:      excute command")
    print("     c       cache la commande du header")
    print("     t:      type du mail")
    print("     X       fonctionelle avec le mode -e xxxx, ne change pas le sujet sur exit code")
    print("     T       mode tee affiche a l'ecran")
    print("     D       debug")
    print("     h       Helpeur")
    print("     V       Version")
    sys.exit(123)


try:
    opts, args = getopt.getopt(sys.argv[1:], "hVDEi:s:d:r:f:m:e:ct:XT", ["help"])
except getopt.GetoptError as err:
    print(err)  # will print something like "option -a not recognized"
    usage()
    sys.exit(2)

debug=False
emptySend=False
subject=f"//cron//{os.path.basename(__file__)}"
inReplyTo=None
dest=os.environ["LOGNAME"]
messageId=os.path.basename(__file__)
cmd=None
mailType=None
replyTo=os.environ["LOGNAME"]
exitReact=True
teeMode=False
mailFrom=None
#-e "set content_type=text/html" 
cmdCache=False

for opt,arg in opts:
    if   opt in '-h':
        usage()
    elif opt in '-V':
        version()
    elif opt in '-D':
        debug=True
    elif opt in '-E':
        emptySend=True
    elif opt in '-i':
        inReplyTo=arg
    elif opt in '-s':
        subject=arg
    elif opt in "-d":
        dest=arg
    elif opt in '-f':
        mailFrom=arg
    elif opt in "-r":
        replyTo=arg
    elif opt in "-m":
        messageId=arg
    elif opt in "-e":
        cmd=arg
    elif opt in '-t':
        mailType=arg
    elif opt in '-X':
        exitReact=False
    elif opt in '-T':
        teeMode=True
    elif opt in '-c':
        cmdCache=True
    

if inReplyTo is None:
    inReplyTo=hashlib.md5(subject.encode('utf-8')).hexdigest()
if mailFrom is None:
    mailFrom=replyTo
if "<" not in mailFrom:
    tmp=mailFrom
    mailFrom=f'{tmp.split("@")[0]} <{tmp}>'
    if debug:
        print(f"{tmp} ET {mailFrom}")
        print(f'{tmp.split("@")}')

# Preparation Ouverture du mail 1/2
muttcmd=['mutt','-e',f'my_hdr X-cronMutt: cronMutt-{Version}','-e',f'my_hdr X-cronMuttStart: {str(datetime.now())}','-e',f'my_hdr From:{mailFrom}','-e',f'my_hdr In-Reply-To: {inReplyTo}','-e',f'my_hdr Message-ID: {messageId}']


# Ouverture du process a suivre
errs=[]
if cmd is not None:
    if not cmdCache:
        muttcmd.append('-e')
        muttcmd.append(f'my_hdr X-cronMuttCmd: {cmd}')

    ps=subprocess.Popen(['/bin/sh','-c',cmd],encoding ='utf-8',
                         stdin=subprocess.PIPE,
                         stdout=subprocess.PIPE,
                         stderr=subprocess.PIPE)
    inf, errs = ps.communicate()

    muttcmd.append('-e')
    muttcmd.append(f'my_hdr X-cronMuttExitCode: {str(ps.returncode)}')

    if exitReact and ps.returncode != 0:
        tmp=subject
        subject="*** "+tmp
        if debug:
            print(f"exit={ps.returncode}")
else:
    inf = sys.stdin

# Preparation Ouverture du mail 2/2
muttcmd.append('-s')
muttcmd.append(subject)

if mailType is not None:
    muttcmd.append('-e')
    muttcmd.append(f'set content_type=text/{mailType}')
if ps.returncode != 0:
    muttcmd.append('-e')
    muttcmd.append(f'my_hdr X-Priority:1')
muttcmd.append('--')
muttcmd.append(dest)

if debug:
    print(f"{' '.join(muttcmd)}")


# Traitement des donnees
datas=""
for line in inf:
    if teeMode:
        print(line,end="")
    datas+=line
if cmd is not None:
    if len(errs):
        datas+="\n=============================================================================\n"
        for line in errs:
            if teeMode:
                print(line,end="")
            datas+=line

# Emission de la donnee
if not (not emptySend and not len(datas)):
    subprosend(muttcmd,datas)
    if debug:
        print("Sended")

if debug:
    print(len(datas))